@using Microsoft.JSInterop
@implements IAsyncDisposable
@inject ILogger<FocusRegion> Logger
@inject IOverlayEventProvider OverlayEventProvider
@inject IJSRuntime JsRuntime

<div class="focus-region @Class"
     style="@Style"
     @ref="@ContainerElement"
     @onfocusin="@OnFocusReceived"
     @onfocusout="@OnFocusLost">
    @ChildContent(CurrentContext)
</div>

@code
{

    const int DebounceIntervalMs = 50;

    private JsComponentInterop<FocusRegion>? _interop;
    private CancellationTokenSource _focusLostCancellation = new(0);

    [Parameter]
    [EditorRequired]
    public required RenderFragment<Context> ChildContent { get; set; }

    [Parameter]
    public string? Class { get; set; }

    [Parameter]
    public string? Style { get; set; }

    public bool HasFocus { get; private set; }

    public ElementReference? ContainerElement { get; private set; }

    private Context CurrentContext
        => new(this);

    public async Task FocusAsync()
    {
        if (ContainerElement is not null)
        {
            await ContainerElement.Value.MudFocusFirstAsync();
        }
    }

    private async Task OnFocusReceived()
    {
        if (HasFocus)
        {
            //? focus received while still in-focus - cancel any pending focus loss handling
            await _focusLostCancellation.CancelAsync();
            return;
        }

        HasFocus = true;
        Logger.LogDebug("Focus received");
        await InvokeAsync(InitializeInteropAsync);
    }

    protected override void OnInitialized()
    {
        base.OnInitialized();
        OverlayEventProvider.OverlayBlurred += OnOverlayOutOfFocus;
    }

    private async void OnOverlayOutOfFocus(object? sender, EventArgs e)
    {
        try
        {
            await OnFocusLost();
        }
        catch (Exception)
        {
            // ignored
        }
    }

    private async Task OnFocusLost()
    {
        try
        {
            // debounce focus loss handling
            _focusLostCancellation = new CancellationTokenSource();
            await Task.Delay(DebounceIntervalMs, _focusLostCancellation.Token);
        }
        catch (OperationCanceledException)
        {
            //? debounce cancelled - event lost and again received focus very quickly, no need to change state
            return;
        }

        HasFocus = false;
        Logger.LogDebug("Focus lost");
        await InvokeAsync(StateHasChanged);
        await InvokeAsync(DisposeInteropAsync);
    }

    private async Task InitializeInteropAsync()
    {
        if (ContainerElement is not null)
        {
            _interop ??= JsRuntime.CreateLifetimeInterop(this);
            await _interop.InitializeAsync(ContainerElement);
        }
    }

    private async Task DisposeInteropAsync()
    {
        if (_interop is not null)
        {
            await _interop.DisposeAsync();
            _interop = null;
        }
    }

    public record Context(FocusRegion SourceRegion)
    {
        public bool ContainsFocus
            => SourceRegion.HasFocus;

        public bool DoesNotContainFocus
            => !ContainsFocus;
    }

    public async ValueTask DisposeAsync()
    {
        OverlayEventProvider.OverlayBlurred -= OnOverlayOutOfFocus;
        await DisposeInteropAsync();
    }
}
