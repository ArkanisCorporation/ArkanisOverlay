@using Arkanis.Overlay.Components.Extensions
@using Arkanis.Overlay.Domain.Models.Keyboard
@using Microsoft.Extensions.Logging
@inject ILogger<KeyboardShortcutInput> Logger

<div @onkeydown:preventDefault="true"
     @onkeydown:stopPropagation="true"
     @onkeyup:preventDefault="true"
     @onkeyup:stopPropagation="true">
    <MudTextField
        @ref="_textField"
        Label="@Label"
        Value="@Value.Description"
        Required="@false"
        Error="@(ErrorText is not null)"
        ErrorText="@ErrorText"
        HelperText="@HelperText"
        AdornmentIcon="@MaterialSymbols.Outlined.KeyboardKeys"
        Immediate
        Clearable="@(!Domain.Models.Keyboard.KeyboardShortcut.None.Equals(Value))"
        OnClearButtonClick="OnClear"
        @onkeydown="OnKeyDown"
        @onkeyup="OnKeyUp"/>
</div>

@code
{

    private MudTextField<string>? _textField;

    private bool _finalized = true;
    private Timer? _finalizeTimer;
    private readonly List<KeyboardKey> _releasedKeys = [];

    [Parameter]
    public string Label { get; set; } = string.Empty;

    [Parameter]
    public string? HelperText { get; set; } = "Focus this input and press the desired keys";

    [Parameter]
    public Domain.Models.Keyboard.KeyboardShortcut Value { get; set; } = Domain.Models.Keyboard.KeyboardShortcut.None;

    [Parameter]
    public EventCallback<Domain.Models.Keyboard.KeyboardShortcut> ValueChanged { get; set; }

    [Parameter]
    public bool Required { get; set; }

    private string? ErrorText
        => Required && Value.IsEmpty
            ? "This field is required"
            : Value.IsValid == false
                ? "This shortcut cannot be used"
                : null;

    protected override void OnInitialized()
    {
        base.OnInitialized();
        _finalizeTimer = new Timer(FinalizeAsync, null, Timeout.InfiniteTimeSpan, Timeout.InfiniteTimeSpan);
    }

    private bool AreAnyKeysPressed()
    {
        lock (_releasedKeys)
        {
            // keys that have been pressed have all been released
            return Value.PressedKeys.SetEquals(_releasedKeys);
        }
    }

    private void ClearReleasedKeysFromKeyPress()
    {
        lock (_releasedKeys)
        {
            _releasedKeys.ForEach(key => Value -= key);
            _releasedKeys.Clear();
        }
    }

    private async Task OnKeyDown(KeyboardEventArgs eventArgs)
    {
        // a key has been pressed
        var keyboardKey = eventArgs.GetKey();
        Logger.LogDebug("Key pressed: {KeyboardKey} ({KeyboardEventArgs})", keyboardKey, eventArgs);

        if (_finalized)
        {
            // the shortcut has been previously finalized, start from scratch
            Value = Domain.Models.Keyboard.KeyboardShortcut.None;
            _finalized = false;
        }

        lock (_releasedKeys)
        {
            // remove any released keys from the shortcut
            ClearReleasedKeysFromKeyPress();

            Value += keyboardKey;
        }

        await UpdateValueAsync();
    }

    private void OnKeyUp(KeyboardEventArgs eventArgs)
    {
        // a key has been released
        var keyboardKey = eventArgs.GetKey();
        Logger.LogDebug("Key released: {KeyboardKey} ({KeyboardEventArgs})", keyboardKey, eventArgs);

        lock (_releasedKeys)
        {
            _releasedKeys.Add(keyboardKey);
        }

        // start a timer to remove the key
        //   or to finalize the shortcut
        _finalizeTimer?.Change(TimeSpan.FromMilliseconds(250), Timeout.InfiniteTimeSpan);
    }

    private async void FinalizeAsync(object? state)
    {
        // input timeout has expired
        try
        {
            if (AreAnyKeysPressed())
            {
                ClearReleasedKeysFromKeyPress();
                await InvokeAsync(UpdateValueAsync);

                return;
            }

            lock (_releasedKeys)
            {
                _releasedKeys.Clear();
                _finalized = true;
            }

            if (_textField is not null)
            {
                // unfocus the input element to disable keyboard handling
                await InvokeAsync(() => _textField.BlurAsync());
            }

            Logger.LogDebug("Shortcut finalised: {KeyboardKey}", Value.Description);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Could not finalize keyboard shortcut input");
        }
    }

    private async Task OnClear()
    {
        Value = Domain.Models.Keyboard.KeyboardShortcut.None;
        await UpdateValueAsync();
    }

    private async Task UpdateValueAsync()
    {
        await ValueChanged.InvokeAsync(Value);
        if (_textField is not null)
        {
            await _textField!.SetText(Value.Description);
        }
    }

}
