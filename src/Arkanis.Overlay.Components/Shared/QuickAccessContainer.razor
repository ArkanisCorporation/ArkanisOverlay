@using Microsoft.JSInterop
@implements IAsyncDisposable
@inject IJSRuntime JsRuntime
@inject ILogger<QuickAccessContainer> Logger

<FocusRegion @ref="_regionRef">
    <CascadingValue Value="@(this)" IsFixed>
        @ChildContent(this)
    </CascadingValue>
</FocusRegion>

@code
{
    private IJSObjectReference? _module;
    private IJSObjectReference? _controls;
    private DotNetObjectReference<QuickAccessContainer>? _selfReference;

    private readonly List<Item> _items = [];

    private FocusRegion? _regionRef;

    [Parameter]
    [EditorRequired]
    public required RenderFragment<QuickAccessContainer> ChildContent { get; set; }

    [Parameter]
    public string QuerySelector { get; set; } = "*";

    [Parameter]
    public bool ContentVirtualized { get; set; }

    public async Task<IAsyncDisposable> RegisterAsync(int index, ElementReference element, EventCallback<ItemInfo> callback)
    {
        var item = new Item
        {
            Index = index,
            Element = element,
            Callback = callback,
            DisposeFunc = UnregisterAsync,
        };
        lock (_items)
        {
            _items.Add(item);
            _items.Sort();
        }

        if (_controls is not null)
        {
            await _controls.InvokeVoidAsync("updateDebounced", 150);
        }

        return item;
    }

    private async Task UnregisterAsync(Item item)
    {
        lock (_items)
        {
            _items.Remove(item);
        }

        if (_controls is not null)
        {
            try
            {
                await _controls.InvokeVoidAsync("updateDebounced", 150);
            }
            catch (JSDisconnectedException)
            {
            }
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _selfReference = DotNetObjectReference.Create(this);
            _module ??= await JsRuntime.InvokeAsync<IJSObjectReference>(
                "import",
                $"./_content/{SharedComponentsModule.Namespace}/{nameof(Shared)}/{nameof(QuickAccessContainer)}.razor.js"
            );
            IEnumerable<string> features = ContentVirtualized
                ? []
                : ["dom"];
            _controls = await _module.InvokeAsync<IJSObjectReference>("QuickAccessContainer.createFor", _selfReference, _regionRef!.ContainerElement, QuerySelector, features);
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    protected override async Task OnParametersSetAsync()
    {
        if (_controls is not null && ContentVirtualized)
        {
            Logger.LogDebug("Requesting JavaScript logic to update");
            await _controls.InvokeVoidAsync("updateDebounced", 150);
        }

        await base.OnParametersSetAsync();
    }

    [JSInvokable]
    public async Task OnJsUpdateAsync()
    {
        Item[] items = [];
        lock (_items)
        {
            items = _items.ToArray();
        }

        Logger.LogDebug("Updating {ItemCount} items within this quick access container", items.Length);
        var firstVisibleItemIndex = await FindFirstVisibleItemIndex(items);
        var pastVisibleItems = false;
        foreach (var item in items)
        {
            var visibilityInfo = item.Index < firstVisibleItemIndex || pastVisibleItems
                ? ItemInfo.Empty
                : await _controls!.InvokeAsync<ItemInfo>("getVisibilityInfo", item.Element);

            if (item.Index > firstVisibleItemIndex && !visibilityInfo.IsVisible)
            {
                pastVisibleItems = true;
            }

            await item.UpdateInfoAsync(visibilityInfo);
        }
    }

    private async Task<int?> FindFirstVisibleItemIndex(Item[] items)
    {
        var itemIndexOffset = 1;
        var alreadyFoundVisible = false;

        for (var itemIndex = 0; itemIndex < items.Length; itemIndex += itemIndexOffset)
        {
            var item = items[itemIndex];
            var visibilityInfo = await _controls!.InvokeAsync<ItemInfo>("getVisibilityInfo", item.Element);
            if (visibilityInfo.IsVisible)
            {
                if (itemIndex == 0)
                {
                    // this item is visible and is the first item, so we can skip the rest
                    return item.Index;
                }

                // this item is visible, so we can change the direction and find the first visible item
                alreadyFoundVisible = true;
                itemIndexOffset = -1;
            }
            else if (alreadyFoundVisible)
            {
                // this item is not visible, but we have already found a visible item before,
                //  so the previous item is the first visible item
                return items[itemIndex + 1].Index;
            }
            else if (itemIndexOffset < 4)
            {
                // we haven't found a visible item yet, increase the offset to skip more items
                itemIndexOffset *= 2;
            }
        }

        return null;
    }

    public class Item : IComparable<Item>, IAsyncDisposable
    {
        public required int Index { get; init; }
        public required Func<Item, Task> DisposeFunc { get; init; }
        public required ElementReference Element { get; init; }
        public required EventCallback<ItemInfo> Callback { get; init; }

        public async ValueTask UpdateInfoAsync(ItemInfo info)
        {
            if (Callback.HasDelegate)
            {
                await Callback.InvokeAsync(info);
            }
        }

        public async ValueTask DisposeAsync()
            => await DisposeFunc(this);

        public int CompareTo(Item? other)
            => Index.CompareTo(other?.Index ?? int.MinValue);
    }

    public record ItemInfo(int Index, bool IsVisible)
    {
        public static readonly ItemInfo Empty = new(0, false);
    }

    public async ValueTask DisposeAsync()
    {
        try
        {
            if (_controls != null)
            {
                await _controls.InvokeVoidAsync("dispose");
                await _controls.DisposeAsync();
            }

            if (_module != null)
            {
                await _module.DisposeAsync();
            }
        }
        catch (JSDisconnectedException)
        {
        }

        _selfReference?.Dispose();
    }
}
