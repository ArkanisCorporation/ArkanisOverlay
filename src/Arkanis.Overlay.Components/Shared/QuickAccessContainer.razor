@using Microsoft.JSInterop
@using MoreLinq
@implements IAsyncDisposable
@inject IJSRuntime JsRuntime
@inject ILogger<QuickAccessContainer> Logger

<FocusRegion @ref="_regionRef">
    <CascadingValue Value="@(this)" IsFixed>
        @ChildContent(this)
    </CascadingValue>
</FocusRegion>

@code
{
    private IJSObjectReference? _module;
    private IJSObjectReference? _controls;
    private DotNetObjectReference<QuickAccessContainer>? _selfReference;

    private readonly List<Item> _items = [];

    private FocusRegion? _regionRef;

    [Parameter]
    [EditorRequired]
    public required RenderFragment<QuickAccessContainer> ChildContent { get; set; }

    [Parameter]
    public string QuerySelector { get; set; } = "*";

    [Parameter]
    public bool ContentVirtualized { get; set; }

    public async Task<IAsyncDisposable> RegisterAsync(ElementReference element, EventCallback<ItemInfo> callback)
    {
        var item = new Item
        {
            Element = element,
            Callback = callback,
            DisposeFunc = UnregisterAsync,
        };
        lock (_items)
        {
            _items.Add(item);
        }

        if (_controls is not null)
        {
            await _controls.InvokeVoidAsync("updateDebounced", 150);
        }

        return item;
    }

    private async Task UnregisterAsync(Item item)
    {
        lock (_items)
        {
            _items.Remove(item);
        }

        if (_controls is not null)
        {
            try
            {
                await _controls.InvokeVoidAsync("updateDebounced", 150);
            }
            catch (JSDisconnectedException)
            {
            }
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _selfReference = DotNetObjectReference.Create(this);
            _module ??= await JsRuntime.InvokeAsync<IJSObjectReference>(
                "import",
                $"./_content/{SharedComponentsModule.Namespace}/{nameof(Shared)}/{nameof(QuickAccessContainer)}.razor.js"
            );
            IEnumerable<string> features = ContentVirtualized
                ? []
                : ["dom"];
            _controls = await _module.InvokeAsync<IJSObjectReference>("QuickAccessContainer.createFor", _selfReference, _regionRef!.ContainerElement, QuerySelector, features);
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    protected override async Task OnParametersSetAsync()
    {
        if (_controls is not null && ContentVirtualized)
        {
            Logger.LogDebug("Requesting JavaScript logic to update");
            await _controls.InvokeVoidAsync("updateDebounced", 150);
        }

        await base.OnParametersSetAsync();
    }

    [JSInvokable]
    public async Task OnJsUpdateAsync()
    {
        Item[] items = [];
        lock (_items)
        {
            items = _items.ToArray();
        }

        Logger.LogDebug("Updating {ItemCount} items within this quick access container", items.Length);
        var firstVisibleItemIndex = await FindFirstVisibleItemIndex(items);
        var pastVisibleItems = false;
        foreach (var (itemIndex, item) in items.Index())
        {
            var visibilityInfo = itemIndex < firstVisibleItemIndex || pastVisibleItems
                ? ItemInfo.Empty
                : await _controls!.InvokeAsync<ItemInfo>("getVisibilityInfo", item.Element);

            if (itemIndex > firstVisibleItemIndex && !visibilityInfo.IsVisible)
            {
                pastVisibleItems = true;
            }

            await item.UpdateInfoAsync(visibilityInfo);
        }
    }

    private async Task<int?> FindFirstVisibleItemIndex(Item[] items)
    {
        var itemIndexOffset = 1;
        var alreadyFoundVisible = false;

        for (var itemIndex = 0; itemIndex < items.Length; itemIndex += itemIndexOffset)
        {
            var item = items[itemIndex];
            var visibilityInfo = await _controls!.InvokeAsync<ItemInfo>("getVisibilityInfo", item.Element);
            if (visibilityInfo.IsVisible)
            {
                if (itemIndex == 0)
                {
                    // this item is visible and is the first item, so we can skip the rest
                    return 0;
                }

                // this item is visible, so we can change the direction and find the first visible item
                alreadyFoundVisible = true;
                itemIndexOffset = -1;
            }
            else if (alreadyFoundVisible)
            {
                // this item is not visible, but we have already found a visible item before,
                //  so the previous item is the first visible item
                return itemIndex + 1;
            }
            else if (itemIndexOffset < 4)
            {
                // we haven't found a visible item yet, increase the offset to skip more items
                itemIndexOffset *= 2;
            }
        }

        return null;
    }

    public class Item : IAsyncDisposable
    {
        private ItemInfo? _previousInfo;

        public required Func<Item, Task> DisposeFunc { get; init; }
        public required ElementReference Element { get; init; }
        public required EventCallback<ItemInfo> Callback { get; init; }

        public async ValueTask UpdateInfoAsync(ItemInfo info)
        {
            if (info == _previousInfo)
            {
                return;
            }

            _previousInfo = info;
            if (Callback.HasDelegate)
            {
                await Callback.InvokeAsync(info);
            }
        }

        public async ValueTask DisposeAsync()
            => await DisposeFunc(this);
    }

    public record ItemInfo(int Index, bool IsVisible)
    {
        public static readonly ItemInfo Empty = new(0, false);
    }

    public async ValueTask DisposeAsync()
    {
        try
        {
            if (_controls != null)
            {
                await _controls.InvokeVoidAsync("dispose");
                await _controls.DisposeAsync();
            }

            if (_module != null)
            {
                await _module.DisposeAsync();
            }
        }
        catch (JSDisconnectedException)
        {
        }

        _selfReference?.Dispose();
    }
}
